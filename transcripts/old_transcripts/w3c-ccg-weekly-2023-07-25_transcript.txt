 All right, I think the recording is on now. So the meetings are being recorded and it's automatically transcribed. We will publish the meetings and recordings in the transcription in the day or two after this meeting. We use GCHAT to queue speakers during the call so you can type in QPlus to add yourself to the queue or Q minus to remove. And you can do a queue question mark to see who is in the queue. All right. Any introductions or reintroductions? You are new to the community or you are just recently re-engaging with the community, please feel free to unmute. Oh, I thought I would say hi. This is Ed Eichold. I haven't been on this call for quite a while. Been part of the VC community generally and using DIDS on the Cardano blockchain and building a identity wallet for that chain. Hi, everyone. Hi. Welcome back, Ed. Anyone else? All right. Next we have announcements and reminders. Any announcements? Hey, Mani, please. Yeah, just a couple. The first one is the selective disclosure cryptography suite. We had asked for a demonstration of support from the community for the ECB's crypto suite. We got really good turnout for that. We have multiple global standards organizations also supporting the ECDSA for selective disclosure. Crypto suite including GS1, Knexis, which does global retail standards, GS1 that does global supply chain standards and one ed tech that does global education standards, all using verifiable credentials in JSON-LD and that sort of thing. So that's kind of item one. As a result of that, we have put out new features in the ECDSA crypto suite that the verifiable credentials working group is developing. So those links to those pull requests went out last Friday as well. So that's just a heads up that's going on there. A lot of that stuff is going to help BBS as well, the BBS crypto suite. There are a number of selective disclosure primitives in there that are just generally useful to a variety of selective disclosure mechanisms. So that's item one. The second item, which is also good news, is the RDF data set canonicalization working group at W3C is at a point where they're feature complete with the RDF data set canonicalization work, which means that we're pretty much ready to go into candidate recommendation with that specification. If folks remember, that is a specification that this community incubated for many years before handing it over to a working group. So they're going into candidate rec, which basically means feature complete done. We have no major issues open on the spec. So that's also good news. Third set of good news is that the HTTP signature specification that was incubated in this community for almost a decade, probably seven years, is in working group last call at ITF. So this is work that Justin Richard and Annabelle Bachmann have been doing. They've been doing fantastic work, getting the specification through the ITF process. And we're looking forward to that stuff being an official ITF RFC soon. We use this community uses that specification for doing things like invoking authorization capabilities and single shot access to HTTP endpoints that use DIDS as the authentication mechanism and so on and so forth. So that's good news. Good news number four is that the multi-format working group at ITF looks like it's going to be formed. In this community, the CCG has incubated multi hash, multi key, multi base and both multi base end, multi hash are in a charter that is going to be proposed to the internet engineering steering group in two weeks time. We're expecting it to be adopted and that works official standardization journey on the ITF standards track. So that's all super great news, right? I mean, those are all things that were incubated in this community, going to ITF, going to W3C and getting their way through the process. Okay. That's it for updates from me, Harrison. Oh, thanks, Monique. A lot of great news. I'll reach out to you and then coordinate with you on getting some of these topics to our future agenda, if you don't mind. Sounds great. Thanks. Cool. All right. Next, we got, Econo. Hi, Harrison. Can you hear me? Yes. Happy Tuesday. I just wanted to make the announcement that rebooting the Web of Trust 12 will be coming up here in September. We'll be convening in Cologne, Germany from September 18th to the 22nd. Tickets are available on Eventbrite. I'll drop the link in the chat. That's it. Thank you. Great. Thanks a lot. And then Dimitri. Thanks to add to what Erica said. The week before rebooting Web of Trust, we have the W3CT pack, which is the yearly W3C conference in, that's going to be in Seville, Spain. And then the week before that is going to be the first instance of the D Webcamp conference in Brazil. And I'll paste the link in chat. So three conferences back to back, Brazil. And that's it. Thanks. Thank you. Any other announcements or reminders? Right. Any update on the work items? Bonnie, please. Yes. It is a request into the chairs of the CCG to approve the confidence method specification. So I think it's kind of hanging out there. And we're blocked at VCWG for the adoption of that item. We have three people that have volunteered to lead that item at this point. I believe it's met all of its requirements. So we just need the chairs to take an action so that we can move that specification over to the CCG so that the URLs resolve so that we can put some specification text into the VC data model spec. Harrison, do you have an ETA? I just need to tell the VC working group when that's going to be done. Do you have an ETA on when that approval might happen? I will sync up with Mike and Kimberly today or this weekend and we'll get a result. Excellent. Thank you. Cool. Thank you. Any other updates on the work items? All right. All right. So let's get to the agenda. So I think earlier in April or May, we actually approved one of the work item verifiable credentials rendering methods. So today, just very excited to have Monya and Dimitri here to present and lead a discussion on this topic. So Monya, Dimitri, the floor is yours. All right. Thank you so much. So welcome everyone. We're going to talk about a really exciting and timely because I think a lot of VC implementers are hitting up against this pain point right now. Topic which is how do you display their fable credentials? So Monya, it's okay with you. I can go over the slide deck and you feel free to jump in at any point. Absolutely. Thank you so much, Dimitri. All right. Okay. So real quick, let's let's say some context. Why are we even talking about this? Why do we need general purpose VC display methods? As you can probably guess or have already encountered some issuers like universities and governments really care about how their VCs look. They really want them to be displayed consistency consistently in wallets. Now, in the VC community, in the decentralized and dare I say self sovereign sort of mindset, we recognize that there's no way that the issuers can enforce or guarantee. But it would be nice if we had a mechanism where they could at least hint politely ask, hey, if you don't care and you're going to be displaying these credentials, here's a template you can use. And the thing is for busy implementers, that sort of help, that sort of I don't have to figure out how to lay out a diploma, a student ID, a government credential, all that stuff. As an implementer, I'll welcome any help I can get because displaying the verifiable credentials is one of the most common operations that we do with them, even more common than issuing and verifying. The other reason that it's a really relevant sort of pain point right now is, of course, going from paper to digital and back. So in a lot of use cases, for example, James Chartrand from McMaster University, who's I think is here on the call, has already ran into this in his pilots with university. They're using verifiable credentials for diplomas and so on. Students are crossing the borders and the border guards don't know anything about VCs. They don't have any special purpose VC verifying software. They at best have a phone with a camera and they can scan QR codes. And so it's really important for students to be able to present their credential in a way that's possible and understandable to regular people. Brind it out on paper with a QR code that can work in a general purpose way without specialized software. And then of course, the other reason is we want VCs to be able to be translated into different modes, from visual to audio to tactile to constrained visual environments, such as FedCM in the browsers. So what do we have? Like given that we need to display verifiable credentials and there are just a million different verifiable credentials. There's a potential infinity of different types. What is an implementer to do? So we have a couple of options. Option one that has been popular in the pre-verifiable credentials world, in the open badges world, is to essentially bake a badge into a static image, to a PNG for example, and embed that PNG in the badge itself. And so it's great in terms of you can get pixel perfect exactly how the issuer wants the thing to be displayed. But of course, once you start displaying on different screens, you run into the same challenges that browsers run into with various sized images. And there's no universal standard aside from the individual standards like open badges version two was doing or some of the other projects. The next two options are the most common. This is two and three is what 99.9% of the wallets are doing right now. So any wallet that you're going to encounter, they're doing either two or three. So two is you have a lot of if then statements or more likely case statements that says if I encounter a credential and I look in its type field and I recognize the type there such as student ID credential. Then I'm going to display this specialized component that I put together that my graphic designers sat down and wrote the react or view JS or whatever templating language you use. Somebody at the implementer sat down and made a layout and the wallet to verify all the other software is just switching off of the type. Do we know how to handle this thing? Yes. So I'm going to handle it in that way. Now what happens in the most common case where you don't know how to handle a special purpose credential, right? We want our walls to be universal and so chances are guaranteed that you're going to encounter a credential with a new type that you don't know how to lay out. And so far the only real option that we have is to loop through all the verify credential properties and just list them out. Think of an unordered list of keys and values. And of course it helps if the credential is flat but the moment you have any kind of multiple levels of depth, it becomes awkward. Do you lay it out visually with indents? Do you use dot notation? That sort of thing. So different implementers do different stuff. Of course there is hope to be able to augment this notion of just listing all of the fields by guessing at the field types, right? That this is a string, this is a date, et cetera. By other looking at the JSON schema, if it's specified in the verify credential or sometimes looking at the context. Now what would be amazing, the options that we really want to be able to display credentials is again if the issue itself could give us a hint, could provide either a pre-baked image or better yet a template, a flexible template that works on different screen sizes and so on that we could use. Of course once we've got that going, we can do all sorts of interesting things like we can compile directories of common templates. We can have community templates for very common verify credential display types and use those in combination with the other CCG work item which is known issuer and verify lists. We could add to that a third thing which is known template lists or something. So this work in its current incarnation began at our rebooting web just 11 where a number of us on this call came together to write a paper on rendering verifiable credentials and there's a demo video of how it works in the browser because Charles Lainer was very kind to, in the blink of an eye put together a demo based on main progress paper. And the paper incorporated in it some of the existing credential rendering proposals such as the two diff proposals while at rendering and credential manifest. And then we also looked at the traceability vocab, again work item of this group, template work, right? So as much as possible we tried to unify and support all of these existing specs and proposals and also just provide a general purpose method that is flexible in the future. And so just recently the VC render method was adopted as a CCG work item so we're very excited about that. Okay so what does this look like? Here's a verifiable credential familiar to all of us. This is data model V1 but it would look exactly the same in V2. We're adding an optional field called render method. And what is in it? It's an array of method hints. So here's a very simple one. It says wallet, look in the render methods and one of your options is you can display this credential as an SVG. So the issuer conveniently put together an SVG either fully rendered or a template that you can fill out using the data from the verifiable credential. And so it's just the type, the location of where you fetch it from the web or better yet from your local cache and the media type so that the wallet knows what to display when and how to actually lay it out in HTML and react in whatever it's using. So that's a general type. So all of the examples that you're going to be seeing will have these two or more fields. So it required the ID and the type so the wallet knows what to do with it and then a number of optional fields such as media type. Personally I do think media type should be required. This part of the feature discussion. So render method, another top level field in the verifiable credential, it's optional. It provides hints from the issuer on how to display stuff. Here's a little more complicated method taken from the render method spec itself, the current work item which is it's got the type, it's got the ID where to fetch it. We've got a name in case the wallet wants to present several choices to the user. It's got a CSS media query so that it knows how to orient it. And then it's got the last field at the bottom. It's got to essentially digest hash to secure to integrity protect the contents of the credential. And we're going to get into the various options available there. So this just demonstrates that the render method objects themselves, the hints are fairly extensible and you can get as detailed or as bare bones with them as you'd like. Here's another example which is near and dear to our hearts over on the VC edU side which is of course PDF. So as I mentioned it's a incredibly common pain point and use case. We have a digital credential. We have this JSON object. We need to turn it into a PDF. How do we do that? Well so one easy way to do that is again for the issuer to provide a PDF template and templating is a common operation in the PDF world. Adobe writes about it and has all sorts of tools. There's libraries and various programming languages on how to take a PDF, use it as a template and fill it out with fields. So again, similar pattern as before. You've got an ID of where to fetch it. We've got the type, media type and of course the securing digest. And so if I'm implementing a wallet and I want to print button on a credential, I look to see if I already have a hard code template, then I look to see if there's one in the render method. And then of course if I don't encounter one, we're back to guessing and what the layout should be. We're back to essentially printing out a flat list of all of the fields in the JSON object which I think we can all agree is suboptimal experience, print wise. Okay, so we mentioned the digest hash. So of course one of the most common questions we hear is how do we trust the template provider? Because template provider has a lot of power if the wallets help us the templates, use the rendering hints. How do we trust them? Well, for methods included in the verifiable credential itself, you're relying on the same trust bottle as the issuer. So if there's signature verifies and optionally the issuer is an unknown issuer list for you as a verifier, you have no reason not to also trust this other field from the issuer which is the render method. In the future for community templates, the question of trust is a little bit harder so we can reuse the exact same mechanism that we do with known verifiers and issuers. And then of course we should always keep in mind that the displaying application, so the wallet, the verifier, should always feel free to override or ignore the suggested render method because we want the user to be in control. We want the software developer to be in control also. So we have all of the usual mechanisms for ensuring template integrity. If you're storing the template externally, you can use quote unquote trust registries or known issuer lists or you can use hash based linking. You can use the already mentioned digest multibased or recently the verifiable credential 2.0 working group added a section to the spec called integrity of related resources which does the same thing. It adds a section to the verifiable credential that links to resources and provides a digest hash of them. And of course the common question is so what's the difference between these two methods? Digest multibased is smaller so it makes for more compact credentials but the integrity of related resources spec is included in the base data model, verifiable credential data model itself. So it's going to hopefully see a lot of implementation. So those are the two trade off. One smaller but less known, the other one's more verb both and more standard in that it's part of the specification. And then of course you can always, instead of using external integrity or known lists, you can just stuff the entire template into the verifiable credential itself just like using embedded images for example, which is simpler, allows you to reuse the credentials own signature for integrity protection but of course, substantially increases the size of the credential just like same trade off as embedding images in the VC. You're either hash linking or you're embedding in which case is going to be huge. And sometimes that's okay. And then as I mentioned before for advanced sort of use cases, we just like with cascading style sheets, there's the same sort of principle, we can apply a cascading series of overrides where the wallet, you can imagine the wallet going down this list each time it wants to figure out how to render it, right? Is there a render method from the issuer or a brand owner? We're not going to get into too much discussion of that here. It's a notion of publisher and brand owner is a common type of conversation in the education space. Right. So you either use the render method from the issuer or overriding it with wallet specific preferences. You can use trusted directories of templates and who knows, maybe we'll get into same thing same way that we have ringtone marketplaces, we could have credential display marketplaces, although that sounds nightmarish. So I hope we don't get there. Another advanced topic that has been brought up is, hey, if we have this wave rendering credentials, could we use the same technique to express a different brand identity for the issuer? So if it's an international company and it's known by this name in the US region and it's known by a different legal name in the European region, you could conceivably render it with different letterhead, with different logos, etc., through your render method template. The same principle that we use in internationalizing and localizing their private credentials. So again, we're running into that in our pilots in the edge space where we have a Mexican university that wants to issue multilingual credentials in Spanish and English. And as always, there's the option of, do they just issue two copies of the same credential, one in English and then the exact same credential in Spanish? That is a valid option. And then you hand both to the user and have the user be able to present in whatever appropriate case, whichever one they want. So that is always an option. But for a lot of use cases, it's really convenient for the issuer to have one credential that contains translations for multiple languages. And fortunately, the Verifiable Credential Data Model has that mechanism built in. You can pull up the Verifiable Credential spec and look at the internationalization, section where you can see that you can specify default languages, you can specify. You can override languages per individual claim, all sorts of things. And of course, if you overdo it, if you offer the same credential in 20 different languages, it certainly increases the size. And similarly, if you're on top of translation, are doing different render methods based on the regions that can combinatorially interact with translation and just make for really huge VCs. So it's an advanced topic, but I just wanted to add it. And this is just an example, a mock example of what that would look like. This one uses the DIF credential manifest rendering hint based on the DIF spec. That adds the language and then the region, jurisdiction, tag, so that Waller could select which render method to display based on that. Quick side note in the VC spec directory, of course. E, since it's an item, oh, I was going to say it's the CCG item, but it's not. It's the VC working group item. Well, okay, so for those who may not be familiar, aside from the main VC data model 2.0 spec, the new VC working group also has this extension mechanism list of sub specifications and proposals from the community that involve verifiable credentials. So there are separate specs for different proof methods. There are specs for their detailed specifications for existing VC fields like status, like evidence. And of course, proposals for new optional verifiable credential properties, such as the render method. So the render method is a perfect example of an item that lives in the VC specification directory. And yeah, these are just some of the examples of what lives in there, aside from the proof methods. We've got this render method based on the paper and further work with the community. We've got this notion of composable credential using digest multi-based. And then we have the verifiable issuers and verifiers list that is also a really exciting development in the community. And we're going to pause here for questions. And Monique, you want to add anything? Oh, you did such a wonderful job to me, Treet. I have next to nothing to add. That was fantastic. Thank you. I guess one thing that I wanted to go back to that you had mentioned was kind of accessibility needs. So as many of you in the education space or if you work with governments know, there are requirements to make the things you create compliant with people's accessibility needs. So if people have a site accessibility is hearing accessibility needs, our technologies are supposed to cater for that. So for example, a verifiable credential that only has a visual depiction is problematic for someone that can't see. And so that's where you would want something like a render method that would render to audio so that if they were to use an accessible device to get such a verifiable credential, that it would be read out loud to them instead of them just not being able to interact with the system. So there's a lot of hope and promise, I think, in the accessibility community that the work that we're doing here in the verifiable credentials community will one empower people with accessibility needs with digital credentials that also catered to the needs that they have. So all that to say, governments have requirements around accessibility. If they issue a credential, they have to be able to say that they're doing it in a way that does not marginalize communities in render method is one of the mechanisms that can be used to kind of achieve that. But other than that, Tamitri, that was fantastic. You hit on every major point. And associated with this work. Thanks. Thank you. Harrison, I think you're up next. Yeah, I would imagine a lot of issuers or brands, like they want to have some kind of assurance that, you know, their credentials and, you know, basically are displayed in a consistent manner or a manner that they approve, right? So, like, for example, I would imagine that hypothetical situations like DMBs don't want, like California DMBs don't want their driver license to display in different ways by different wallets or different presenters. So is there a way to, for the issuers to have that kind of assurance that the presenters and wallets are displaying these, you know, verifiable credentials or badges in the constant manner? Great question. Great question. And it sounds like a model also wants to give an answer, but I'll answer real quick that this is a social and legal problem and not a technical one. Because there's no technical way to enforce even in theory, consistent display, because that's essentially a form of DRM. So there's no way to absolutely guarantee it. But there are much like with DRM. There are certainly legal ways to highly encourage on the one end and punish on the other. And so then it becomes a notion of the issuers, regulate or convince software providers to when you encounter a credential from me, and maybe we can add different types or watermarks to the render method. Property when you encounter this credential, you better display it as such. Right. So when when doing the negotiation of which wallet to issue the credential to and requiring the various wallet data stations, because we certainly don't want to issue based on wallet provider companies, no, we want wallets to be able to give generic data stations. So that's one mechanism that issuers could use to to enforce that. Manu, were you hoping to answer that question? Yeah, yeah. I mean, plus one to everything he said, Dimitri, there's a really interesting dynamic that's happening here and render method is kind of the one of the it's kind of like the tip of the iceberg, right? It's the easiest to kind of try and tackle. So what Dimitri was saying, we are our company engages with state and federal governments and they are very concerned about their citizen credentials being displayed in a way that they do not approve of. The other thing that they're concerned about is that when their credential is displayed, they're concerned that the person looking at the display is not actually going to believe it's a valid credential. Right. So, so one, they're very, very concerned about the brand and image of, you know, the state being upheld when the thing is displayed. And they're also concerned that when the thing is displayed, is the person looking at it going to believe it if it's a legitimate ID. Right. So those are, I mean, that is very much going into like the current thinking of, of, you know, states and governments and in large organizations issuing credentials. They, they're, you know, they're, they're marketing and branding teams want strong control over how the thing is rendered. But at the same time, and this is, this is kind of the thing that fights counter to it, they want open ecosystems, they want like open wallet ecosystems. And so, you know, the conversation, like it kind of goes like this. It's, it's like, you know, the government says, Hey, we want an open wallet ecosystem. And we're like, great, you know, the VC, you know, ecosystem is an open, can be an open wallet ecosystem. But then the next statement is, but we really want to make sure that when somebody renders our credential, it looks exactly like this. And then we're kind of like, well, you can have an open wallet ecosystem, but you can't simultaneously also have that. And then, and then, you know, the large organizations are like, Oh, well, then we're going to vet our wallet providers and only allow certain wallet providers to hold our credentials. And at that point, we're like, okay, well, you're not quite an open wallet ecosystem at that point, right? If you, if you lock it down to only a few, you know, wallet providers. Now the counter to that is exactly what the Metri said. It's, it's make it so that the wallets can provide attestations, general attestations, not like I am, you know, a wallet from giant big tech company X. And therefore you can trust, you know, trust me that I'm going to do the right thing with the credential. So render method is like right in the middle of that, there's this push and pull on open wallet ecosystems, but still being able to, you know, render things in a certain way. That same push and pull has to do with like key management and security. And when you're allowed to like share the credential, and so on and so forth. So, so this is all like kind of tip of the iceberg stuff that we're dealing with in the digital community. So that's it, you know, it's a, it's a great, you know, question Harrison. I think we're all still trying to figure out, you know, what the right balance is. I think many of us do not want to sacrifice an open wallet ecosystem. You know, that's the primary, you know, we're talking about self-summer identity. We're talking about individuals having the right to own their data. Once you start imposing limits on that individual, about which wallets that they can use, you're now down a slippery slope to, you know, big tech providers potentially nudging people towards their solution, which is not, you know, as open as the, as the, an open wallet ecosystem. That's it. Thanks, Fano. And just to add to that, real quick. So we're, the other thing to keep in mind is that we already live in this world in a lot of aspects of information. Look at the browser. The user always can change the CSS of any website, even if it's a government website, even if it's a, if it's Coca-Cola or some other brand that really cares about their branding. I can, as a user, pull up their site, change the color scheme, change the fonts to papyrus, I can do anything I want, right? And there's no, there's no technological way to prevent me from doing that, unless you get into a horrible DRM territory. But of course, in Verifiable Credentials, this becomes a lot more relevant. And so yeah, that's what our stations are for. Got it. Thanks. Phil, you're next. Yeah, thanks. Great presentation, Manu and Dimitri. This is kind of following on your, your section of more advanced topics. And I'm curious about the use cases where the display actually wants to combine information from different credentials into a common display of some sort. I know that, you know, Adobe is working on that and, and there are other approaches to considering how to do that. But I wonder if you've given that consideration and perhaps you can talk a little bit about what is, what is being done out there, either by Adobe or others, do you think they'd be relevant? Thanks. Oh, what a great question. So I'll, I'll, I'll touch on Adobe separately. Manu, do you think it makes sense to provide an example from the age verification world? Sure. And so in, in what way, maybe you could start off the Metri and then I can, I can, I can, yeah. Yeah. So, so we have an example of exactly this. So in age, in true age credentials, where the credentials are composable, that there is a, there's an outer container credential that hash links to smaller different credentials that there's an overall container that links to a person's picture and then to their age category. And so essentially, if the true age system wanted a consistent way of, here is how you take these three credentials and compose them together visually. That's, that's definitely something that they could put in a template, just have a staple that template to the container credential and use that now. Like you said, it's definitely a, a, a, a, a, a usage. Manu, go ahead. Yeah, that's exactly right. The Metri, I think, Phil, you know, one of the, one of the challenges here with like, rendering of multi credential is, is that if you're pulling the data from outside of the credential, like, like for as, as Demetri said, if you've hash linked to stuff, that rendering language will be more complex, right? I mean, it will need to understand how to pull in all these different credentials and render them in some kind of form. It is, it is absolutely doable. Like that is, that is a doable thing, but it is technically complicated. So if you were to look at something that, for, to kind of as, to provide a, a easier example to, to implement, if you were looking for something that had a, had like a top level credential subject, and then a whole bunch of other credentials embedded in that credential, where all of the data was local, you know, it was signed, you know, hash, like, but it was all local, that type of rendering is, is much easier to accomplish. So I think we're very much early days when it comes to like, rendering of complex compound credentials. And, you know, there's, there's quite a bit of work that that needs to be done there. I think probably the first set of like quick wins is going to be in the some of the simpler use cases. So for, to give you an example, and Demetri was talking about, you know, the true age program, the true age program utilizes a compound credential. So it's got this outermost wrapper. That's got, you know, an individual's picture, but that individual's picture, it never, it never leaves their wall. The true age program never sees like the, the, you know, the photo of the person. The only thing the true age program, you know, gets is like a driver's license number, which is then immediately tokenized and like doubly encrypted and locked away. And what you're left with is, are these random numbers, the tokens, the true age tokens, which are rendered as QR codes, right? So the, the only thing that the individual has, you know, in their digital wallet is this compound credential that contains a bunch of different things that can be a bunch of different random numbers, 90 byte random numbers, that can be rendered as a QR code, which is a verifiable credential. So one of the, one of the big challenges with version one of true age, that's, that's out there today, is that we told the wallets that they have to render the QR code, like they have to take the binary and convert it into C bore LD, and then render it as a QR code. And that was before render method existed. You know, today, if we had to do it again, we would have just used render method and say, Hey, here's a, here's a PNG that you need to show on the screen. So, so when they go to display it, the wallet doesn't have to have all this complicated logic about, you know, how to, how to transform to see more LD and how to take that to a QR code. Instead, the wallet can just say, Oh, I've got a render method here. I'm just going to render this as an image. Right. So that's an example of like, the way we used to kind of address this problem before. And if render method, you know, gets traction and, and, you know, people start using it, we would have a much simpler way to try and address the problem. But going back to your compound credential problem, I think that's still a hard problem. Like we're, we're very early days in trying to figure out how that could work. That's it. And then, Adrian, do you want to expand on what is going on elsewhere there? Oh, yeah. So, uh, I think the only other thing that, uh, I would add to that is this notion of compound credentials is so it's, uh, it's deployed in interage and it's an item of great interest in education space because we have these, um, CLR V2. We have this comprehensive learner record, which is a kitchen sink, sort of laundry list of all of your achievements as, as a student. In one big compound verifiable credential. So it doesn't use hash links. It embeds all the sub credentials into one outer one. And again, that's a lot of the wallets, uh, are going to be wrestling with how do we display that? And in the, uh, forecast or the possibilities for using something from the PDF world to accomplish some of this? Ah, okay. Yeah. So let's, uh, uh, we've got, we've got a few minutes. So let's talk about the PDF world. Uh, but Mona, go ahead. I was, I was going to say, you know, render method, the way it's, the way that it's, it's, uh, contemplated right now, um, uh, is kind of like attached to the verifiable credential, right? But Dimitri also highlighted some really, uh, interesting ways that we could maybe decouple it from the verifiable credential, like have rendering templates for presentations, or have a rendering, it's like a rendering template for a CLR V2, um, would be simultaneously easy and difficult to do because, because rendering, you know, like if we took like an SVG thing, like it's not programmatic. Like, you know, a CLR has like a bunch of different classes in it. And, um, you know, if you wanted some kind of generalized rendering mechanism, um, is, I don't, I don't think it would be easy to do for, for, uh, CLR in kind of like a generative way, right? But, um, if we take a step back and look at render method as like, this is a design pattern. And, um, maybe what we can do is just in time render templates that would take in a CLR V2 and create programmatically create an SVG that could be used to render a CLR V2 or render a presentation. Like let's say somebody shows up with like, you know, uh, they're, they're getting a job and they show up with like a driver's license and a utility bill to demonstrate that there are a person that exists that's recognized by, you know, a government and utility companies and they show up with a couple of open badges. Um, you could create a render template that takes all of that information and then renders it to the screen. Like if that is a common set of things that people provide your organization, your software developers and designers might say, oh, we're going to create a render template for this particular type of presentation. Um, again, early days, who knows, you know, where that's going to go, but it's certainly a possibility. Right. Uh, Harrison, go ahead. You're on the queue. Yeah. A quick question on the CLR, like, is, uh, does this compound presentation just show a bunch of credentials? Like, as it is, or does it attempt to kind of merge all the different, um, like elements, uh, you know, so for example, if the, the elements for, uh, of age, like shows all the different credentials, they're just trying to merge and do conflict resolutions. Uh, great question. Well, so, yeah, uh, nobody knows, uh, because literally that question, a bunch of developers are in board rooms right now arguing about how to do that. So, uh, there's no standard yet. It's every wall that implementers is trying to figure out how to do this. Got it. Okay. Thanks. Uh, so let's say a few words about PDFs. So this is a general pattern in verifiable credentials. On how do you secure external binaries? So we know how to secure, let's say, JSON object, and heavens for fan XML objects. Uh, but what about, how do I secure a PDF or a PNG or, I don't know, a Word doc? There's only two ways to do that. Uh, I can either issue a regular verifiable credential, familiar JSON object, and hash link to the binary resource. That's fundamental option one. And then fundamental option two is if the binary file has a separate metadata option, I can, I can hash link, uh, the contents of the P of the PDF and put it in the separate PDF metadata that every PDF file has. And so Adobe has a way of, of doing that. It's called C2PA. It's, uh, something, something content protection alliance. Uh, and it's a way to say, here's how you hash the contents of a PDF. Here are the metadata fields that you can use for this. So could you theoretically embed a verifiable credential in the metadata of the PDF? Yes. Uh, I don't think anybody's done that yet. Adobe themselves is building in the tooling, uh, for, for the C2PA into PDF viewer, Photoshop, all these different things. I don't think they're using verifiable credentials though. I think they're, they're, uh, using their own digital signatures. They actually have a verifiable credential subsection for how to do it that way. Oh, excellent. And I'll put in the technical spec, the technical spec doc image. Yeah. Excellent. Yeah. Uh, but that's a, that's a slightly different problem. Um, it's not a different problem. It's just a, uh, complementary way of doing it. So you can either issue a standalone verifiable credential and use the render method to points to a PDF, which is the printed version of that, or you can do the opposite, which is, issue a PDF and then embed a verifiable credential into its metadata. So those are the yin and yang of, uh, of dealing with PDFs and other binary objects. Any other quick questions? I've got two minutes till the top of the hour. Thank you. No, I think we're good. So thanks Dimitri. Thanks, Moni, for a great presentation today. Thanks, everyone. Cheers. Harrison, uh, here's the, here's the link to the slides. If you want to mail it out, uh, um, I would do that for, okay, cool. Okay. Great. I would do that. Thanks, Dimitri. And, uh, yeah, I think this concludes this week's, uh, CCG meeting. Uh, so thanks for, thanks everyone for attending. Cheers all. Cheers. Thank you.